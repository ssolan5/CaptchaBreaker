\section{System Overview}
\label{sec:system}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{figures/breaker_arch.pdf}
\caption{Overview of the \system system and the captcha-solving workflow..}
\label{fig:breaker}
\end{figure}

In this section we first present an overview of \system's design and describe the automated 
captcha-solving process. We then offer more details on our system's implementation.

\subsection{\system Design}

One of the main goals of our work is to explore the effectiveness of different speech recognition
services against a large number of different audio captcha services. To that end, we opted for 
a modular design for \system, as that provides flexibility in adding support for new captcha 
systems and speech recognition APIs. Our system is comprised of 3 basic components. The main 
component is responsible for the browser automation and handles all browser-related actions,
including crawling and rendering webpages, extracting the audio captchas, and providing the solutions
to the challenges. It also performs specific actions to mimic a user's steps and avoid triggering  
checks implemented by the captcha services for detecting bots (e.g., mouse over actions, or text 
box highlighting before solutions are input).
The second component completes some pre-processing and configuration steps 
necessary before the audio recordings are passed to the speech recognition services. The final 
component handles the post-processing of the transcribed text for preparing the solution that will
be submitted to the captcha service.

Figure~\ref{fig:breaker} presents the main components of \system and outlines the workflow of
an automated attack against a target website that protects a specific action with a captcha 
service that also supports audio challenges.

\protect\circlea{\small 1} Our system visits a webpage that offers the desired functionality 
(e.g., account creation, message posting, etc.). After identifying the captcha element within 
the page, the audio challenge is extracted.

\protect\circlea{\small 2} The audio file is passed to the pre-processing component. The audio 
file is then converted to a lossless format. Then, based on the captcha service, our system 
selects the speech recognition service with the best results for the specific challenge. 

\protect\circlea{\small 3} The audio file is uploaded for transcription by the module that handles that solver, 
together with a predetermined configuration. The configuration allows us to fine-tune the transcription process
for better results; specifically we restrict the dictionary used by the solver (e.g., to only expect  
numbers) as well as the accent classifier to use (services may support multiple English accents 
-- British, American etc.).

\protect\circlea{\small 4} The transcription of the audio challenge is obtained from the solver 
and passed to the post-processing component. Based on the originating captcha service, the corresponding  
module will process the transcription and prepare the solution to the challenge. If a service employs the 
NATO phonetic alphabet, the transcribed words will be mapped to the letters they represent. For instance, 
``Alpha Bravo'' will be substituted with ``AB''. Furthermore, \note{we have created a manually curated dictionary 
per service and solver with homophones that may lead to errors. For example, $\{two,too,to\}$ should all 
be mapped to $\{2\}$ in a captcha service that only employs numerals in the audio challenges.}

\protect\circlea{\small 5} The final solution is passed to the browser automation module,
which is responsible for passing the captcha challenge.

\protect\circlea{\small 6} The browser automation module inputs the solution while mimicking 
user behavior, as certain captcha services have deployed extra checks for identifying bots.
It also verifies whether the solution was accepted by the captcha service.

\subsection{Implementation Details}

\textbf{Browser automation.}
To create the bot we utilized the browser automation framework known as selenium. This was 
the tool of our choice as it is hard to detect scraping/botting written utilizing the selenium 
webdriver and your browser of choice. Selenium communicates with browsers via a special protocol 
native to each browser and has access to everything loaded for a web site, the JavaScript, the DOM 
and even the secure cookies. The special protocol is required as  Selenium RC uses generic javascript 
for browser automation however executing simply generic javascript violates same origin policy. For 
every website the browser creates a sandbox for the website's javascript, this way the javascript that 
belongs to one website does not execute on another website that is currently loaded on the browser. 
(more detail on cross site scripting). To overcome this Selenium acts as an HTTP Proxy server, when 
we launch the browser through selenium scripts, javascript (Selenium Core) is injected into the browser, 
all subsequents requests are therefore through Selenium. In essence selenium makes the browser think that 
the web application is served from Selenium's domain rather than the actual web server hosting our web 
application.

Selenium driving the browser from within by sitting in as injected Javascript provides certian limitations 
which is handled by "WebDriver" an object oriented api, as the Core is limited by the JavaScript sandbox of 
the browser (Due to same origin policy). The Webdriver, handles the browser from outside the browser. This was 
the marked difference between Selenium 1.0 and Selenium 2.0 as by being limited by the sandbox and therefore 
has reduced functional test coverage. 

[graphic of selenium driving browsers with injected javascript]

\note{Why selenium is better than other botting/scrapers out there --
}

Almost no way to detect the automation except for checking some predefined variables which most websites do not do.

\note{source : https://stackoverflow.com/a/41220267
}

Web Driver is the nearest you can get to an actual person driving the browser automation. Quote:  "Driving a browser natively as a user would either locally or on a remote machine using the Selenium Server it marks a leap forward in terms of browser automation."

\note{source: http://www.seleniumhq.org/projects/webdriver/
}

\note{need better ways to say this}

\note{how do you automatically identify the captcha service being used on a random page?}

\textbf{Speech recognition APIs.} Give some details about the API exposed by each service.

We utilized three different voice recognition services for our system, the python google cloud speech api, 
the ibm bluemix, Wit ai voice recognition services.
